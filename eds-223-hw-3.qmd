---
title: "Identifying the impacts of extreme weather"
author: "Vedika Shirtekar" 
date: "11/8/2025"
format:
  pdf: 
    code-fold: false
execute: 
  warning: false
  message: false
editor: 
  markdown: 
    wrap: 72
editor_options: 
  chunk_output_type: console
---

## Primary Objective

Winter Storm Uri was a powerful and catastrophic winter storm that
devastated several communities in Texas during February 13-17 2021. The
state was unprepared for a significant loss of power; power plants and
grids were not prepared to handle freezing temperatures coupled with
increased electricity usage to heat homes (Zhou et al., 2024). Nearly
246 people perished, 4.5 million homes lost power, and costed the state
about \$195 million in damages (Zhou et al., 2024). As such, Winter
Storm Uri is listed as the costliest and one of the deadliest natural
disasters in Texan history.

Harris County was heavily impacted by the storm. The City of Houston,
the most populous city in Harris County, has a population of 2,333,346
people as of 2024 (City of Houston, .

The purpose of this assignment is to assess the extent to which houses
and census tracts in Houston lost power during Winter Storm Uri. The
analysis utilizes spatial manipulation between raster and vector types
to identify homes in Houston that experienced a blackout, as well as an
assessment of median income for census tracts affected by the blackout
based on socioeconomic data. The following research question was
referenced to guide the analysis:

**To what extent were homes and census tracts in Houston impacted by the
power outage caused by Winter Storm Uri?**

## Workflow

-   find locations that experienced a blackout by creating a mask
-   exclude highways from analysis
-   identify homes that experienced blackouts by combining the locations
    of homes and blackouts
-   identify the census tracts likely impacted by blackout

## Load in required packages

```{r}
#| output: false
# Import packages
library(here) # Load "here" to locate and reference files
library(tidyverse) # Load the tidyverse" for data cleaning
library(sf) # Load "sf" for GIS analysis
library(raster) # Load "raster" for accessing raster data types
library(ggplot2) # Load "ggplot2" for data visualization
library(tmap) # Load "tmap" for functions to create and layer maps
library(kableExtra) # Load "kableExtra" for table formatting
library(stars) # Load "stars" for integration with "sf"
```

## Part 1: Create a Blackout Mask

```{r}
#| output: false 
# Read 
lights1 <- read_stars(here::here("data", "VNP46A1", "VNP46A1.A2021038.h08v05.001.2021039064328.tif"))

lights2 <- read_stars(here::here("data", "VNP46A1", "VNP46A1.A2021038.h08v06.001.2021039064329.tif"))

lights3 <- read_stars(here::here("data", "VNP46A1", "VNP46A1.A2021047.h08v05.001.2021048091106.tif"))

lights4 <- read_stars(here::here("data", "VNP46A1", "VNP46A1.A2021047.h08v06.001.2021048091105.tif"))

```

```{r}
# Do the CRS match? Use series of if statements with warnings
# Create list of spatial objects
spatial_objects <- list(
  lights1 = lights1,
  lights2 = lights2,
  lights3 = lights3,
  lights4 = lights4
)

# Use lights1's CRS as reference
ref_crs <- st_crs(spatial_objects$lights1)

# Check and transform each manually with if/else statements
if (st_crs(spatial_objects$lights2) != ref_crs) {
  warning("lights2 CRS does not match. Transform to match lights1 CRS")
  spatial_objects$lights2 <- st_transform(spatial_objects$lights2, ref_crs)
} else {
  message("lights2 CRS already matches lights1 CRS.")
}

if (st_crs(spatial_objects$lights3) != ref_crs) {
  warning("lights3 CRS does not match. Transform to match lights1 CRS")
  spatial_objects$lights3 <- st_transform(spatial_objects$lights3, ref_crs)
} else {
  message("lights3 CRS already matches lights1 CRS.")
}

if (st_crs(spatial_objects$lights4) != ref_crs) {
  warning("lights4 CRS does not match. Transform to match lights1 CRS")
  spatial_objects$lights4 <- st_transform(spatial_objects$lights4, ref_crs)
} else {
  message("lights4 CRS already matches lights1 CRS.")
}

```

## Create a mask --\> SHOW WHERE AREAS HAD LIGHTS GO OUT

To identify places that experienced a blackout, you should create a
“mask” that indicates for each cell whether or not it experienced a
blackout.

-   find the change in night lights intensity (presumably) caused by the
    storm
-   hint: this will require creating a raster object for each day
    (2021-02-07 and 2021-02-16)
-   reclassify the difference raster, assuming that any location that
    experienced a drop of more than 200 nW cm-2sr-1 experienced a
    blackout
-   assign NA to all locations that experienced a drop of less than 200
    nW cm-2sr-1 change
-   vectorize the blackout mask
-   hint: use st_as_sf() to convert from a raster to a vector and fix
    any invalid geometries with st_make_valid() crop (spatially subset)
    the blackout mask to the Houston area as defined by the following
    coordinates: (-96.5, 29), (-96.5, 30.5), (-94.5, 30.5), (-94.5, 29)
    re-project the cropped blackout dataset to EPSG:3083 (NAD83 / Texas
    Centric Albers Equal Area)

```{r}
# - find the change in night lights intensity (presumably) caused by the storm
# - hint: this will require creating a raster object for each day (2021-02-07 and 2021-02-16)
 

# Need to combine lights rasters for both days  (two for each, then subtract)
# Subtract layers after combining 

# c() for same attributes, same spatial extend and resolution, and different bands. Use when trying to stack data of the same attributes along third dimension (date) while making sure spatial respondence is maintained
# st_mosaic for same thing except different spatial extent and same bands... use when you have multiple separate raster datasets that have different spatial coverages and would like to combine them into one

# - reclassify the difference raster, assuming that any location that experienced a drop of more than 200 nW cm-2sr-1 experienced a blackout

# VNP
# combine obj of same day using st_mosaic
lights_day1 <- st_mosaic(lights1, lights2)  # Feb 7
lights_day2 <- st_mosaic(lights3, lights4) # Feb 16

# Compute difference (Feb 7 - Feb 16)
diff_raster <- lights_day1 - lights_day2

#diff_raster <- diff_raster %>% st_as_sf()
class(diff_raster)
st_crs(diff_raster)
```

```{r}
# Reclassify such that: 1 = blackout (>200 drop), NA = no blackout


## Difference of true (more than 200) or false (less than 200)
# ***feb 7 - feb 16.. HOWEVER, must have difference of more than 200; positive 200 for a drop... true (if more than 200)

## if areas are FALSE (if difference is greater than 200), then assign NAs (assign NA with indexing) --> get difference mask --> st_as_sf() ---> st_make_valid() --> now have vector_difference_mask****
# - assign NA to all locations that experienced a drop of less than 200 nW cm-2sr-1 change
# - vectorize the blackout mask
blackout_mask<- diff_raster
blackout_mask[diff_raster < 200] <- NA

#plot(blackout_mask)

# Vectorize
blackout_mask <- st_as_sf(blackout_mask)
st_is_valid(blackout_mask)
blackout_mask <- st_make_valid(blackout_mask)

class(blackout_mask)
plot(blackout_mask)

# - hint: use st_as_sf() to convert from a raster to a vector and fix any invalid geometries with st_make_valid()
st_is_valid(blackout_mask)

```

```{r}
# crop (spatially subset) the blackout mask to the Houston area as defined by the following coordinates:
# (-96.5, 29), (-96.5, 30.5), (-94.5, 30.5), (-94.5, 29)

## use st_bbox with these coordinates OR st_points() with join... however, NOT layered spatial object with st_bbox(), so use st_as_sf() --> CRS 4326. Next, find where they intersect with difference mask... 
?st_bbox()
# houston <- st_bbox(c(xmin = -96.5, xmax = -94.5, ymin = 29, ymax = 30.5), crs = 4326)
# houston <- st_as_sfc(houston, crs = 4326)  # convert to POLYGON

houston_bbox <- st_bbox(c(xmin = -96.5, xmax = -94.5,
                          ymin = 29,    ymax = 30.5), 
                        crs = 4326)
# check crs (use function for this)
st_crs(houston_bbox) ==
st_crs(blackout_mask)

# convert to sf polygon: boundaries of houston
houston <- st_as_sfc(houston_bbox)

houston_blackout <- st_crop(blackout_mask, houston)



houston <- st_as_sfc(houston_bbox)  # convert bbox to POLYGON
houston <- st_sf(geometry = houston) # make sf object
#st_crs(blackout_mask) <- st_crs(diff_raster)
st_crs(blackout_mask) <- st_crs(lights_day1)

#st_crs(houston) <- st_crs(blackout_mask)
class(lights_day1)
class(blackout_mask)
#st_crs(blackout_mask) <- st_crs(diff_raster)

blackout_mask <- st_make_valid(blackout_mask)
houston <- st_make_valid(houston)


st_crs(houston) == st_crs(houston_blackout)  # match CRS


## st_intersects(st_as_sf(st_bbox), vector_difference_mask) --> st_transform

# re-project the cropped blackout dataset to EPSG:3083 (NAD83 / Texas Centric Albers Equal Area)
houston_blackout <- st_transform(houston_blackout, crs = "EPSG:3083")
```

a set of maps comparing night light intensities before and after the
first two storms

```{r}
## a set of maps comparing night light intensities before and after the first two storms

# change style of scale intervals OR set 65000 to NA

# Add title, change units for legend

# Use the palette function to get a specific number of colors



tm1 <- tm_shape(lights_day2) + tm_raster(col.scale  = tm_scale_intervals(style = "quantile",  n = 10, values = c("black", "darkgrey", "darkorange", "yellow")), col.legend = tm_legend(expression(nW^-2~cm^-2~ sr^-1))) +
  tm_graticules( # Add graticules to establish latitude and longitude network
    col = "black",
    lwd =.8) + # Establish "thickness" of lines
    #alpha = 0.6 ) +  # Specify transparency 
  tm_layout( # Center title outside bounding box
    main.title = "Nighlights of Houston Prior to Winter Storm Uri (Feb 7)", 
   # title.size = 1,
    legend.outside = TRUE, # Place legend outside map frame
    legend.outside.position = "right",
    component.autoscale = FALSE # Disable autoscaling for title
  )


tm2 <- tm_shape(lights_day2) + tm_raster(col.scale  = tm_scale_intervals(style = "quantile",  n = 10, values = c("black", "darkgrey", "darkorange", "yellow")), col.legend = tm_legend(expression(nW^-2~cm^-2~ sr^-1))) +
  tm_graticules( # Add graticules to establish latitude and longitude network
    col = "black",
    lwd =.8) + # Establish "thickness" of lines
    #alpha = 0.6 ) +  # Specify transparency 
  tm_layout( # Center title outside bounding box
    main.title = "Nighlights of Houston After to Winter Storm Uri (Feb 16)", 
    legend.outside = TRUE, # Place legend outside map frame
    legend.outside.position = "right",
    component.autoscale = FALSE # Disable autoscaling for title
  )
 

#tm3 <- tm_shape(diff_raster) + tm_raster(palette="-RdYlBu", title="Change")
# tm4 <- tm_shape(houston_blackout) + tm_polygons() +
#    tm_layout(main.title = "Blackout Map of Houston") + tm_basemap(server= "OpenStreetMap")
tm1
tm2
tmap_save(tm1, "figs/pre_storm.png")
tmap_save(tm2, "figs/post_storm.png")

```

![](figs/pre_storm.png) ![](figs/post_storm.png)

## Exclude highways from the cropped blackout mask

Highways may have experienced changes in their night light intensities
that are unrelated to the storm. Therefore, you should excluded any
locations within 200 meters of all highways in the Houston area.

-   identify areas within 200m of all highways
-   hint: you may need to use st_union
-   find areas that experienced blackouts that are further than 200m
    from a highway

```{r}
# Load in roads 
# Roads
roads <- read_sf(here::here("data", "gis_osm_roads_free_1.gpkg"), query = "SELECT * FROM gis_osm_roads_free_1 WHERE fclass='motorway'")
colnames(roads)

```

```{r}
## st_intersection(): Certain feature that intersects BOTH
## st_union(): return either or... if in A or B 
roads <- st_union(roads)
## buffer then union
# st_transform
# NAD 83
roads <- st_transform(roads, crs = st_crs(houston_blackout))


## identify areas within 200m of all highways
# need in all directions within 200 m... st_buffer() for around highways (uses units of layer... ALWAYS MAKE SURE ST_CRS()$UNITS) 
# Then, disolve acutal highway and buffer with st_union() to get polygon
# crop roads to houston_blackout for easy of running buffer
# roads_houston_crop <- 
roads_buffer_200 <- st_buffer(roads, dist = 200)
highways_200 <- st_union(roads_buffer_200)

#highways_200_m <- st_union(roads_buffer_200)
plot(highways_200)


## now need to disolve 
# We can use st_difference()
?st_difference()
# blackout_not_highway = areas of blackout that do NOT overlap highways
blackout_not_highway <- st_filter(houston_blackout, highways_200, .predicate = st_disjoint)

#plot(st_geometry(highways_200), col = 'red', add = TRUE)
plot(st_geometry(blackout_not_highway), col = 'black', add = TRUE)

plot(blackout_not_highway)

tm_shape(blackout_not_highway) + tm_polygons() +  tm_layout(main.title = "Areas of Houston Blackout That Do NOT Overlap Higways") + tm_basemap(server= "OpenStreetMap") # + add roads (highway+200)

# st_filter(,.predicate = st_disjoint)

# - hint: you may need to use st_union (aggregates data)
# - find areas that experienced blackouts that are further than 200m from a highway
# Now need to find areas further away than 200m from the polygon highways... st_diff/st_disjoint(st_buffer, st_union)

```

## Identify the number of homes likely impacted by blackouts

identify homes that overlap with areas that experienced blackouts

```{r}
# Load in homes 
# Houses
buildings <- read_sf(here::here("data", "gis_osm_buildings_a_free_1.gpkg"))

```

```{r}
## buildings 
## identify homes that overlap with areas that experienced blackouts
# First, layer must be overlapped with areas with non-highway experience blackout (use final output from previous section with output of st_disjoint())
# use any: st.intersection, st_within, st_contains... however, return a different amount of rows and cols... recall than st_intersection considers placement of houses on borders too

## CRS do not match
st_crs(buildings) == st_crs(blackout_not_highway)

# update buildings
buildings = st_transform(buildings, crs = st_crs(blackout_not_highway))



buildings_affected_blackout <- st_filter(buildings, blackout_not_highway, .predicate = st_intersects)

#buildings_affected_blackout_test <- st_intersection(buildings, blackout_not_highway)

tm_shape(buildings_affected_blackout) + tm_polygons(col = "blue")  + tm_layout(main.title = "Houses in Houston Affected By the Blackout") + tm_basemap(server= "OpenStreetMap") ## add just the buildings

# table(buildings_affected$type)
#table(buildings_affected_blackout$type) # residential 



```

## Socioeconomic

-   Read in socioeconomic data
-   Interested in census track, median income, average income in these
    areas

```{r}
# Use a query 
# Read in layers: Geom and income data set
# Because two layers are within two different sf objects but are similar, can left join attributes by Geo_ID
# Why left_join() instead of the spatial? 

buildings_affected_blackout[buildings_affected_blackout$type == "house"]
st_layers(here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"))

# Read in geom layer
# socioeconomic <- read_sf(here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"),
#                     layer = "ACS_2019_5YR_TRACT_48_TEXAS")

geometry_socio <- st_read(here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"),
                    layer = "ACS_2019_5YR_TRACT_48_TEXAS")
#view(geometry_socio)
colnames(geometry_socio)

## Read in attribute data 
attributes_socio <- st_read(here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"),
                      layer = "X19_INCOME")



# Join
names(geometry_socio)
names(attributes_socio)

# Perform left join for combination
socioeconomic <- geometry_socio %>%
  left_join(attributes_socio, by = c("GEOID_Data" = "GEOID"))

# st_transform, then st_join
#socioeconomic <- socioeconomic %>% st_transform()
str(socioeconomic)

colSums(is.na(socioeconomic))

head(socioeconomic)


# After st_join, do data wrangling to summarize median income by census tract

```

## Impacted Census Tracts

```{r}
# Link building locations to acs census tracts... this is the socioeconomic data!
# CRS do not match... maybe put warning?
st_crs(socioeconomic) == st_crs(buildings_affected_blackout)
socioeconomic <- st_transform(socioeconomic, crs = st_crs(buildings_affected_blackout))

acs_affected <- st_filter(socioeconomic, buildings_affected_blackout, .predicate = st_intersects)

str(acs_affected)


# Summary stats
#B19013e1
colnames(acs_affected)
str(acs_affected$B19013e1)
str(acs_affected %>% filter(!(is.na(B19013e1))))
unique(acs_affected$B19013e1)

## get rid of NAs (missing) as shown in legend
acs_income_non_na = acs_affected %>%
  filter(!is.na(B19013e1))

palette = colorRampPalette(c("#f7fcf5", "#74c476", "#00441b"))(10)

  tm_shape(acs_income_non_na) +
  tm_polygons(
    col = "B19013e1",
    palette = palette,  
    style = "quantile",
    n = 10,
    title = "Median Income (USD)", 
   legend.showNA = F
  ) +
  tm_layout(
    main.title = "Census Tracts in Houston Affected by the Blackout Based on Median Income",
    main.title.size = 1,
    main.title.position = "center",
    legend.outside = TRUE,
    frame = T
  ) + 
   tm_graticules( # Add graticules to establish latitude and longitude network
    col = "black",
    lwd = 0.3, # Establish "thickness" of lines
    alpha = 0.6 ) +
  tm_basemap(server = "OpenStreetMap.HOT") 





colnames(acs_affected) 




```

## Summary stats

```{r}

## WHICH CNESUS TRACTS DID NOT EXPERIENCE A BLACKOUT
### need new columnn for "yes" or "no blackout" OR different data frame with no blackout census tracts

## Use option A
## If do column, then do group_by then median income summarize


# Would get number of homes that experienced blackouts 
# homes that experienced blackout (create map and this # if the summary statistic)
## Label unaffected vs affected tracts 
# indicator column 
acs_affected$affected <- "Blackout"
acs_unaffected <- socioeconomic[!(socioeconomic$GEOID %in% acs_affected$GEOID),]
acs_unaffected$affected <- "No Blackout"

# Combine status
acs_compare <- rbind(acs_affected, acs_unaffected)
nrow(acs_compare[acs_compare$affected == "Blackout"])

## Then, ensure income exists
summary(acs_compare$B19013e1)

# Filter out nas
acs_compare <- acs_compare %>% filter(!is.na(B19013e1))

## Plot boxplot
acs_compare %>% ggplot(aes(x = affected, y = B19013e1, fill = affected)) +
  geom_boxplot(alpha = 0.7, width = 0.5, outlier.alpha = 0.3) +
  scale_fill_manual(values = c("Blackout" = "lightblue", "No Blackout" = "red")) +
  labs(
    title =" Median Household Income by Blackout Status in Houston Census Tracts",
    x = "Affected Status",
    y = "Median Household Income (USD)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

n_homes_blackout <- nrow(buildings_affected_blackout)
print(n_homes_blackout)
dim(buildings_affected_blackout) # Estimate of # of houses impacted

nrow(buildings_affected_blackout)


```

```{r}
# kableextra table for summary stats
income_summary <- acs_compare %>%
  # Drop geometry for speed
  st_drop_geometry() %>%
  # Group by blackout
  group_by(affected) %>%
  # Grab median incomes- using metadata
  summarize(
    mean_income = mean(as.numeric(B19013e1), na.rm = TRUE),
    median_income = median(as.numeric(B19013e1), na.rm = TRUE),
    sd_income = sd(as.numeric(B19013e1), na.rm = TRUE),
    n_tracts = n()
  ) 
  
income_

```

## Output

-   Need two maps before and after the storm
-   Map of homes in Houston that lost power
-   A map of census tracts in Houston that lost power
-   Plot comparing distributions of median household income for census
    tracks that did and did not experience blackouts
-   a brief reflection (\~100 words) summarizing results and discussing
    any limitation to this study

limitation: - distance to hospital grid - subsystem bias in GIS -
