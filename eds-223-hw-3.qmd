---
title: "Lights Out in Houston: Mapping the Effects of Winter Storm Uri"
author: "Vedika Shirtekar" 
date: "11/10/2025"
format:
  pdf: 
    code-fold: false
editor: 
  markdown: 
    wrap: 72
editor_options: 
  chunk_output_type: console
---

### Primary Objective

Winter Storm Uri was a powerful and catastrophic winter storm that
devastated several communities in Texas during February 13-17 2021. The
state was unprepared for a significant loss of power; power plants and
grids were not prepared to handle freezing temperatures coupled with
increased electricity usage to heat homes (Zhou et al., 2024). Nearly
246 people perished, 4.5 million homes lost power, and costed the state
about \$195 million in damages (Zhou et al., 2024). As such, Winter
Storm Uri is listed as the costliest and one of the deadliest natural
disasters in Texan history.

Harris County was heavily impacted by the storm. The City of Houston,
the most populous city in Harris County, has a population of 2,333,346
people as of 2024 (City of Houston, .

The purpose of this assignment is to assess the extent to which houses
and census tracts in Houston lost power during Winter Storm Uri. The
analysis utilizes spatial manipulation between raster and vector types
to identify homes in Houston that experienced a blackout, as well as an
assessment of median income for census tracts affected by the blackout
based on socioeconomic data. The following research question was
referenced to guide the analysis:

**To what extent were homes and census tracts in Houston impacted by the
power outage caused by Winter Storm Uri?**

## Workflow

-   find locations that experienced a blackout by creating a mask
-   exclude highways from analysis
-   identify homes that experienced blackouts by combining the locations
    of homes and blackouts
-   identify the census tracts likely impacted by blackout

### Load in required packages

1.  Load in the appropriate packages for the analysis.

```{r}
#| output: false
# Import packages
library(here) # Load "here" to locate and reference files
library(tidyverse) # Load the tidyverse" for data cleaning
library(sf) # Load "sf" for GIS analysis
library(raster) # Load "raster" for accessing raster data types
library(ggplot2) # Load "ggplot2" for data visualization
library(tmap) # Load "tmap" for functions to create and layer maps
library(kableExtra) # Load "kableExtra" for table formatting
library(stars) # Load "stars" for integration with "sf"
```

## Part 1: Create a Blackout Mask

To determine the areas affected by blackouts, a mask was generated to
classify each cell based on whether or not it experienced a blackout.

2.  Read in each `lights` raster using `read_stars()`. Both pre- and
    post- storm days have two tiles per date that must be loaded in and
    combined.

```{r}
#| output: false 
# Read in each raster file as a stars object

# Feb 7
lights1 <- read_stars(here::here("data", 
                                 "VNP46A1", 
                                 "VNP46A1.A2021038.h08v05.001.2021039064328.tif"))

# Feb 7
lights2 <- read_stars(here::here("data", 
                                 "VNP46A1", 
                                 "VNP46A1.A2021038.h08v06.001.2021039064329.tif"))

# Feb 16
lights3 <- read_stars(here::here("data", 
                                 "VNP46A1", 
                                 "VNP46A1.A2021047.h08v05.001.2021048091106.tif"))

# Feb 16
lights4 <- read_stars(here::here("data", 
                                 "VNP46A1", 
                                 "VNP46A1.A2021047.h08v06.001.2021048091105.tif"))

```

3.  Use conditional statements to verify that each `lights` tile has the
    same CRS as `lights1`. If mismatches are found, issue explicit
    warnings and transform the tile CRS to the reference CRS
    (`lights1`).

```{r}
# Do the CRS match? Use series of if statements with warnings
# Create list of spatial objects
spatial_objects <- list(
  lights1 = lights1,
  lights2 = lights2,
  lights3 = lights3,
  lights4 = lights4
)

# Use lights1's CRS as reference
ref_crs <- st_crs(spatial_objects$lights1)

```

```{r}
# Check and transform each tile with if/else statements
if (st_crs(spatial_objects$lights2) != ref_crs) {
  warning("lights2 CRS does not match. 
          Transforming to match lights1 CRS.")
  spatial_objects$lights2 <- st_transform(spatial_objects$lights2, ref_crs)
} else {
  message("lights2 CRS already matches lights1 CRS.")
}
```

```{r}
# Check and transform each tile with if/else statements
if (st_crs(spatial_objects$lights3) != ref_crs) {
  warning("lights3 CRS does not match. 
          Transforming to match lights1 CRS")
  spatial_objects$lights3 <- st_transform(spatial_objects$lights3, ref_crs)
} else {
  message("lights3 CRS already matches lights1 CRS.")
}
```

```{r}
# Check and transform each tile with if/else statements
if (st_crs(spatial_objects$lights4) != ref_crs) {
  warning("lights4 CRS does not match. Transforming
          to match lights1 CRS")
  spatial_objects$lights4 <- st_transform(spatial_objects$lights4, ref_crs)
} else {
  message("lights4 CRS already matches lights1 CRS.")
}
```

-   vectorize the blackout mask
-   hint: use st_as_sf() to convert from a raster to a vector and fix
    any invalid geometries with st_make_valid() crop (spatially subset)
    the blackout mask to the Houston area as defined by the following
    coordinates: (-96.5, 29), (-96.5, 30.5), (-94.5, 30.5), (-94.5, 29)
    re-project the cropped blackout dataset to EPSG:3083 (NAD83 / Texas
    Centric Albers Equal Area)

4.  Combine each tile raster into a single night light raster using
    `st_mosaic()` for each day.

```{r}
# Combine tiles of same day using st_mosaic()
lights_day1 <- st_mosaic(lights1, lights2)  # Feb 7
lights_day2 <- st_mosaic(lights3, lights4) # Feb 16

```

5.  Calculate the change in night light intensity, presumed to result
    from the storm, and store the results in a raster. Reclassify the
    difference raster so that areas with a drop greater than 200 nW cm⁻²
    sr⁻¹ are identified as experiencing a blackout.

```{r}
# Compute difference (Feb 7 - Feb 16)
diff_raster <- lights_day1 - lights_day2

# Double check class of diff_raster
class(diff_raster)
```

```{r}
#Compare values from February 7 to February 16
# Store diff_raster in blackout_mask to create copy
blackout_mask<- diff_raster

# Assign NAs for differences less than positive 200 (inverted drop)
blackout_mask[blackout_mask < 200] <- NA
```

6.  Vectorize the blackout mask using `st_as_sf()` and ensure geometries
    are valid prior to cropping to the bounding box extent.

```{r}
# Vectorize blackmask
blackout_mask <- st_as_sf(blackout_mask) 
blackout_mask <- st_make_valid(blackout_mask)

# Ensure blackout_mask is an sf object
# Use all() to check for whether class() contains "sf" AND "data.frame"
if (all(c("sf", "data.frame") %in% class(blackout_mask))){
  # Pass a message to ensure black_outmask is an sf object
  message("blackout_mask is an sf object 
          and is ready for cropping.")
} else{ # Stop running if not an sf object (still stars object)
  stop("blackout_mask is not an sf object. Double check st_as_sf() output.")
}
```

7.  Create a bounding box using `st_bbox()` for the extent of Houston
    for coordinates: (-96.5, 29), (-96.5, 30.5), (-94.5, 30.5), and
    (-94.5, 29).

```{r}
# Create bounding box using st_bbox()
houston_bbox <- st_bbox(c(xmin = -96.5, # Min longitude
                          xmax = -94.5, # Max longitude
                          ymin = 29,    # Min latitude
                          ymax = 30.5), # Max latitude
                        crs = 4326) # Use EPSG code for CRS

# Double chcek whether CRS is a match
if (st_crs(houston_bbox) != st_crs(blackout_mask)) {
  warning("houston_bbox CRS does not match. 
          Transforming to match blackout_mask CRS")
  # Transform to match blackout_mask CRS
  houston_bbox <- st_transform(houston_bbox, st_crs(blackout_mask))
} else {
  message("houston_bbox CRS already matches blackout_mask CRS.")
}
```

8.  Because `houston_bbox` is a `bbox`, it is necessary to convert it to
    an `sf` spatial type prior to cropping. Convert `houston_bbox` to an
    `sf` polygon type, then use `st_crop()` to crop (spatially subset)
    the blackout mask to the Houston area.

```{r}
# Convert boundaries of Houston to sf polygon 
houston <- st_as_sfc(houston_bbox)
# Render valid geometry for Houston polygon
houston <- st_make_valid(houston)

# Crop blackout mask to Houston boundaries
houston_blackout <- st_crop(blackout_mask, houston)

# Reproject cropped blackout dataset to EPSG:3083 
# (NAD83 / Texas Centric Albers Equal Area)
houston_blackout <- st_transform(houston_blackout, crs = "EPSG:3083")
```

9.  Create two maps using the combine raster tiles of the pre- and post-
    storm days to compare a set of maps comparing night light
    intensities before and after the first two storms

```{r}
# Pre-storm lights
prestorm <- tm_shape(lights_day2) + tm_raster(col.scale  = tm_scale_intervals(style = "quantile",  n = 10, values = c("black", "darkgrey", "darkorange", "yellow")), col.legend = tm_legend(expression(nW^-2~cm^-2~ sr^-1))) +
  tm_graticules( # Add graticules to establish latitude and longitude network
    col = "black",
    lwd =.8) + # Establish "thickness" of lines
    #alpha = 0.6 ) +  # Specify transparency 
  tm_layout( # Center title outside bounding box
    main.title = "Nighlights of Houston Prior to Winter Storm Uri (Feb 7)", 
   # title.size = 1,
    legend.outside = TRUE, # Place legend outside map frame
    legend.outside.position = "right",
    component.autoscale = FALSE # Disable autoscaling for title
  )

# Post-storm lights
tm2 <- tm_shape(lights_day2) + tm_raster(col.scale  = tm_scale_intervals(style = "quantile",  n = 10, values = c("black", "darkgrey", "darkorange", "yellow")), col.legend = tm_legend(expression(nW^-2~cm^-2~ sr^-1))) +
  tm_graticules( # Add graticules to establish latitude and longitude network
    col = "black",
    lwd =.8) + # Establish "thickness" of lines
    #alpha = 0.6 ) +  # Specify transparency 
  tm_layout( # Center title outside bounding box
    main.title = "Nighlights of Houston After to Winter Storm Uri (Feb 16)", 
    legend.outside = TRUE, # Place legend outside map frame
    legend.outside.position = "right",
    component.autoscale = FALSE # Disable autoscaling for title
  )
 

tm1
tm2
tmap_save(tm1, "figs/pre_storm.png")
tmap_save(tm2, "figs/post_storm.png")



```

![](figs/pre_storm.png) ![](figs/post_storm.png)

## Exclude highways from the cropped blackout mask

Highways may have experienced changes in their night light intensities
that are unrelated to the storm. Therefore, you should excluded any
locations within 200 meters of all highways in the Houston area.

-   identify areas within 200m of all highways
-   hint: you may need to use st_union
-   find areas that experienced blackouts that are further than 200m
    from a highway

```{r}
# Load in roads 
# Roads
roads <- read_sf(here::here("data", "gis_osm_roads_free_1.gpkg"), query = "SELECT * FROM gis_osm_roads_free_1 WHERE fclass='motorway'")
colnames(roads)

```

```{r}
## st_intersection(): Certain feature that intersects BOTH
## st_union(): return either or... if in A or B 
roads <- st_union(roads)
## buffer then union
# st_transform
# NAD 83
roads <- st_transform(roads, crs = st_crs(houston_blackout))


## identify areas within 200m of all highways
# need in all directions within 200 m... st_buffer() for around highways (uses units of layer... ALWAYS MAKE SURE ST_CRS()$UNITS) 
# Then, disolve acutal highway and buffer with st_union() to get polygon
# crop roads to houston_blackout for easy of running buffer
# roads_houston_crop <- 
roads_buffer_200 <- st_buffer(roads, dist = 200)
highways_200 <- st_union(roads_buffer_200)

#highways_200_m <- st_union(roads_buffer_200)
plot(highways_200)


## now need to disolve 
# We can use st_difference()
?st_difference()
# blackout_not_highway = areas of blackout that do NOT overlap highways
blackout_not_highway <- st_filter(houston_blackout, highways_200, .predicate = st_disjoint)

#plot(st_geometry(highways_200), col = 'red', add = TRUE)
plot(st_geometry(blackout_not_highway), col = 'black', add = TRUE)

plot(blackout_not_highway)

tm_shape(blackout_not_highway) + tm_polygons() +  tm_layout(main.title = "Areas of Houston Blackout That Do NOT Overlap Higways") + tm_basemap(server= "OpenStreetMap") # + add roads (highway+200)

# st_filter(,.predicate = st_disjoint)

# - hint: you may need to use st_union (aggregates data)
# - find areas that experienced blackouts that are further than 200m from a highway
# Now need to find areas further away than 200m from the polygon highways... st_diff/st_disjoint(st_buffer, st_union)

```

## Identify the number of homes likely impacted by blackouts

identify homes that overlap with areas that experienced blackouts

```{r}
# Load in homes 
# Houses
buildings <- read_sf(here::here("data", "gis_osm_buildings_a_free_1.gpkg"))

```

```{r}
## buildings 
## identify homes that overlap with areas that experienced blackouts
# First, layer must be overlapped with areas with non-highway experience blackout (use final output from previous section with output of st_disjoint())
# use any: st.intersection, st_within, st_contains... however, return a different amount of rows and cols... recall than st_intersection considers placement of houses on borders too

## CRS do not match
st_crs(buildings) == st_crs(blackout_not_highway)

# update buildings
buildings = st_transform(buildings, crs = st_crs(blackout_not_highway))



buildings_affected_blackout <- st_filter(buildings, blackout_not_highway, .predicate = st_intersects)


buildings_affected_blackout_test <- st_intersection(buildings, blackout_not_highway)

tm_shape(buildings_affected_blackout) + tm_polygons(col = "blue")  + tm_layout(main.title = "Houses in Houston Affected By the Blackout") + tm_basemap(server= "OpenStreetMap") ## add just the buildings
```

## Socioeconomic

-   Read in socioeconomic data
-   Interested in census track, median income, average income in these
    areas

```{r}
# Use a query 
# Read in layers: Geom and income data set
# Because two layers are within two different sf objects but are similar, can left join attributes by Geo_ID
# Why left_join() instead of the spatial? 

buildings_affected_blackout[buildings_affected_blackout$type == "house"]

st_layers(here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"))

# Read in geom layer
# socioeconomic <- read_sf(here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"),
#                     layer = "ACS_2019_5YR_TRACT_48_TEXAS")

geometry_socio <- st_read(here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"),
                    layer = "ACS_2019_5YR_TRACT_48_TEXAS")
#view(geometry_socio)
colnames(geometry_socio)

## Read in attribute data 
attributes_socio <- st_read(here("data", "ACS_2019_5YR_TRACT_48_TEXAS.gdb"),
                      layer = "X19_INCOME")



# Join
names(geometry_socio)
names(attributes_socio)

# Perform left join for combination
socioeconomic <- geometry_socio %>%
  left_join(attributes_socio, by = c("GEOID_Data" = "GEOID"))

# st_transform, then st_join
#socioeconomic <- socioeconomic %>% st_transform()
str(socioeconomic)

colSums(is.na(socioeconomic))

head(socioeconomic)


# After st_join, do data wrangling to summarize median income by census tract

```

## Impacted Census Tracts

```{r}
# Link building locations to acs census tracts... this is the socioeconomic data!
# CRS do not match... maybe put warning?
st_crs(socioeconomic) == st_crs(buildings_affected_blackout)

socioeconomic <- st_transform(socioeconomic, crs = st_crs(buildings_affected_blackout))


acs_affected <- st_filter(socioeconomic, buildings_affected_blackout, .predicate = st_intersects)

str(acs_affected)
acs_affected_test <- st_intersection(socioeconomic, buildings_affected_blackout_test)

st_crs(socioeconomic) == st_crs(buildings_affected_blackout_test)



# Summary stats
#B19013e1
colnames(acs_affected)
str(acs_affected$B19013e1)
str(acs_affected %>% filter(!(is.na(B19013e1))))
unique(acs_affected$B19013e1)
acs_affected$tracts <- "Census Tracts"
## get rid of NAs (missing) as shown in legend
acs_income_non_na = acs_affected %>%
  filter(!is.na(B19013e1))

  tm_shape(acs_affected) +
  tm_polygons(
    col = "affected",
    title = "Census Tracts"
   # palette = palette,  
   # style = "quantile",
    #n = 10,
    #title = "Median Income (USD)", 
   #legend.showNA = F
  ) +
  tm_layout(
    main.title = "Census Tracts in Houston Affected by the Blackout",
    main.title.size = 2,
    main.title.position = "center",
    legend.outside = TRUE,
    frame = T
  ) + 
   tm_graticules( # Add graticules to establish latitude and longitude network
    col = "black",
    lwd = 0.3, # Establish "thickness" of lines
    alpha = 0.6 ) +
  tm_basemap(server = "OpenStreetMap") 



## get rid of NAs (missing) as shown in legend
acs_income_non_na = acs_affected %>%
  filter(!is.na(B19013e1))
acs_affected_test$tracts <- "Census Tracts"

  tm_shape(acs_affected_test) +
  tm_polygons(
    col = "tracts",
  #  title = "Census Tracts"
   # palette = palette,  
   # style = "quantile",
    #n = 10,
    #title = "Median Income (USD)", 
   #legend.showNA = F
  ) +
  tm_layout(
    main.title = "Census Tracts in Houston Affected by the Blackout",
    main.title.size = 2,
    main.title.position = "center",
    legend.outside = TRUE,
    frame = T
  ) + 
   tm_graticules( # Add graticules to establish latitude and longitude network
    col = "black",
    lwd = 0.3, # Establish "thickness" of lines
    alpha = 0.6 ) +
  tm_basemap(server = "OpenStreetMap") 
```

## Summary stats

```{r}

## WHICH CNESUS TRACTS DID NOT EXPERIENCE A BLACKOUT
### need new columnn for "yes" or "no blackout" OR different data frame with no blackout census tracts

## Use option A
## If do column, then do group_by then median income summarize


# Would get number of homes that experienced blackouts 
# homes that experienced blackout (create map and this # if the summary statistic)
## Label unaffected vs affected tracts 
# indicator column 
acs_affected$affected <- "Blackout"
acs_unaffected <- socioeconomic[!(socioeconomic$GEOID %in% acs_affected$GEOID),]
acs_unaffected$affected <- "No Blackout"

# Combine status
acs_compare <- rbind(acs_affected, acs_unaffected)
nrow(acs_compare[acs_compare$affected == "Blackout"])

## Then, ensure income exists
summary(acs_compare$B19013e1)


# Filter out nas
acs_compare <- acs_compare %>% filter(!is.na(B19013e1))

## Plot boxplot
acs_compare %>% ggplot(aes(x = affected, y = B19013e1, fill = affected)) +
  geom_boxplot(alpha = 0.7, width = 0.5, outlier.alpha = 0.3) +
  scale_fill_manual(values = c("Blackout" = "lightblue", "No Blackout" = "red")) +
  labs(
    title =" Median Household Income by Blackout Status in Houston Census Tracts",
    x = "Affected Status",
    y = "Median Household Income (USD)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

n_homes_blackout <- nrow(buildings_affected_blackout)
print(n_homes_blackout)
dim(buildings_affected_blackout) # Estimate of # of houses impacted

nrow(buildings_affected_blackout)


```

```{r}
# kableextra table for summary stats
income_summary <- acs_compare %>%
  # Drop geometry for speed
  st_drop_geometry() %>%
  # Group by blackout
  group_by(affected) %>%
  # Grab median incomes- using metadata
  summarize(
    mean_income = mean(as.numeric(B19013e1), na.rm = TRUE),
    median_income = median(as.numeric(B19013e1), na.rm = TRUE),
    sd_income = sd(as.numeric(B19013e1), na.rm = TRUE),
    n_tracts = n()
  ) 
  
income_

```

## Output

-   Need two maps before and after the storm
-   Map of homes in Houston that lost power
-   A map of census tracts in Houston that lost power
-   Plot comparing distributions of median household income for census
    tracks that did and did not experience blackouts
-   a brief reflection (\~100 words) summarizing results and discussing
    any limitation to this study

limitation: - distance to hospital grid - subsystem bias in GIS -
